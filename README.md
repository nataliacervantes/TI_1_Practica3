# TI_1_Practica3

Se crean los ejercicios correspondientes al desarrollo de la práctica 3. A continuación se describe cada uno de los apartados.


* MODULES : son aquellas librerías que serán necesarias para realizar cálculos matemáticos, generar gráficas, trabajar con pandas entre otros.
* CLASSES : clase que nos ayudaba con el cálculo de los giros en las trayectorias. No utilicé esta clase en ninguno de los ejercicios
* FUNCTIONS: en este apartado almaceno las funciones que fueron implementadas para los ejercicios 1, 2, 3 y 4. 
  * **euclidean_function**: recibe dos parámetros, las posiciones inicial y la final de la distancia que deseo calcular y calculo utilizando la función euclidiana: Raíz cuadrada     de la sumatoria de la diferencia de los puntos al cuadrado
  *  **msd**: se utiliza para calcular el mean square displacement para las trayectorias browniana y correlational, recibe tres parámetros que nos ayudan a crear apartir de 3 puntos dos vectores. Después generamos  
  *  **angle_calculate**: esta función también nos crea dos vectores apartir de los puntos recibidos pero además calcula el ángulo que existe entre ambos vectores mediante la fórmula  donde  optenemos el producto escalar de los vectores obtenidos, después la magnitud del vector 1 y 2 después se procede a calcular el coseno de teta donde dividimos el producto escalar sobre la multiplicación de las magnitudes para finalmente despejar teta y obtener nuestro resultado, pero no sin antes calcular el sentido de giro del vector mediante el cálculo de la dirección de los vectores.
* Actividad 1: Path Length - (BM1 vs BM2 vs CRW): en la entrada siete se cargan las trayectorias que previamente se proporcionaron. En la siguiente entrada se crea un arreglo donde en cada posición llamamos la función euclidiana y almacenamos el resultado, después en otro arreglo vamos agregando en cada posición la suma acumulada de los valores obtenidos en el arreglo anterior y procedemos a graficar nuestro resultado. Al ser valores incrementales positivos obtenemos un trazo lineal positiva en ambos ejes
* Actividad 2: Mean Squared Displacement - (Brownian vs CRW): En la entrada 17 o In(17) tenemos nuestro desarrollo para el cálculo del MSD donde cargamos las trayectorias a estimar, después recorremos en un bucle anidado la lista obtenida y por cada vuelta que demos a esa lista, recorreremos la misma lista pero calculando el MSD según sea su valor en la posición del primer arreglo, es decir según el valor de tau. Nuestro parámetro de paro del for anidado es el total de valores menos el valor que tenga tau en ese momento para evitar salir de los index del arreglo, aquí adentro mandamos a llamar a la función de msd y el resultado de obtenemos lo vamos acumulando en una variable para que después de terminar de recorrer la lista, realicemos el cálculo del promedio y guardemos el resultado en un arreglo. A continuación en una variable auxiliar creamos el dataframe del arreglo esto por cada trayectoria recorrida, al finalizar procedemos a llamar a la función to_csv para generar un archivo csv que podamos descargar y ahí  observar los resultados de nuestra función. En la siguiente entrada procedemos a graficar.
*  Actividad 3: Turning-angle Distribution - (Dist. origen vs Dist. observada): en este apartado mediante un ciclo for almacenamos dentro de un arreglo auxiliar el resultado que nos devuelve la función de angle_calculate la cual mandamos a llamar en cada posición del arreglo pasándole como parámetros la posición anterior a la iteración, la actual y la siguiente así hasta terminar de recorrer el arreglo. Después procedemos a crear un data frame de cada cálculo realizado y a generar su csv, usando el mismo método que en la explicación anterior. Finalmente generamos el histagrama y los valores de la distribución de origen.
*  Actividad 4: Step-length Distribution - (Dist. origen vs Dist. observada): para este ejercicio cargamos las trayectorias de tipo levy y procedemos a calcular el ángulo entre vectores usando la función angle_calculate, como en el resultado nos muestra los ángulos de giro y existen algunos pasos en los que no se giró, se procede a limpiar este arreglo con otro for donde iremos contando en cada vuelta cuántos pasos se dieron hasta girar, ese resultado se almacena en un arreglo el cual llevará el conteo de los pasos realizados entre cada giro del arreglo, finalmente se realiza mismo procedimientos que actividades 2 y 3, se genera un dataframe, un csv y los histogramas y gráficas correspondientes a este resultado. (ojo: el histograma de esta trayectoria no me dió así que está comentado).
